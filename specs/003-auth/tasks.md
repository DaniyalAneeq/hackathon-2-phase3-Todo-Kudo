# Tasks: Authentication & Route Protection

**Input**: Design documents from `/specs/003-auth/`
**Prerequisites**: plan.md, spec.md
**Branch**: `003-auth`
**Agent Delegation**: Tasks are assigned to specialized sub-agents (database-dev-agent, backend-dev-agent, frontend-dev-agent, qa-spec-validator)

**Tests**: Tests are NOT included in this implementation. Manual verification will be performed per user story acceptance criteria.

**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.

## Format: `- [ ] [ID] [P?] [Story?] Description`

- **[P]**: Can run in parallel (different files, no dependencies)
- **[Story]**: Which user story this task belongs to (e.g., US1, US2, US3)
- Include exact file paths in descriptions

## Path Conventions

- **Backend**: `backend/app/` for source code, `backend/alembic/versions/` for migrations
- **Frontend**: `frontend/app/` for pages, `frontend/components/` for components, `frontend/lib/` for utilities

---

## Phase 1: Setup & Configuration

**Purpose**: Project initialization, environment setup, and MCP context verification
**Agent**: database-dev-agent

- [X] T001 [MCP Context] Use Neon MCP `list_projects` to verify Neon database connection and list available projects
  - **Verification**: Run `mcp__neon__list_projects` and confirm project appears in list

- [X] T002 [MCP Context] Use Neon MCP `describe_project` to get project details and confirm DATABASE_URL is correct
  - **Verification**: Run `mcp__neon__describe_project` with project ID and verify connection string matches `.env`

- [X] T003 Generate `BETTER_AUTH_SECRET` using `openssl rand -base64 32` and update both `.env` files
  - **Files**: `backend/.env`, `frontend/.env` (was `.env.local`, updated to match actual file)
  - **Verification**: Run `grep BETTER_AUTH_SECRET backend/.env frontend/.env` and confirm both files have identical secrets

- [X] T004 [P] Install Better Auth dependencies in frontend: `better-auth @better-auth/react`
  - **Location**: `frontend/`
  - **Command**: `cd frontend && npm install better-auth @better-auth/react`
  - **Verification**: Run `grep "better-auth" frontend/package.json` and confirm dependencies added

- [X] T005 [P] Install JWT dependencies in backend: `python-jose[cryptography] passlib[bcrypt]`
  - **Location**: `backend/`
  - **Command**: `cd backend && pip install python-jose[cryptography] passlib[bcrypt]`
  - **Verification**: Run `pip list | grep -E "python-jose|passlib"` and confirm both packages installed

---

## Phase 2: Database Schema & Migration (Foundational)

**Purpose**: Create Better Auth tables and migrate existing tasks table
**Agent**: database-dev-agent

**‚ö†Ô∏è CRITICAL**: No user story work can begin until this phase is complete

- [X] T006 [MCP Context] Use Better Auth MCP to search knowledge base for database schema requirements
  - **Query**: "Better Auth database schema for email/password authentication"
  - **Verification**: Review returned schema information and confirm User, Session, Account table structures

- [X] T007 Use Neon MCP `provision_neon_auth` to generate Better Auth schema (User, Session, Account tables) in Neon database
  - **Verification**: Run `mcp__neon__get_database_tables` with project ID and confirm User, Session, Account tables exist

- [X] T008 Create Alembic migration `001_add_better_auth_tables.py` for Better Auth schema (if not auto-generated by Neon MCP)
  - **File**: `backend/alembic/versions/001_add_better_auth_tables.py`
  - **Content**: SKIPPED - Neon MCP `provision_neon_auth` automatically created tables in `neon_auth` schema
  - **Verification**: Tables created in `neon_auth` schema (user, session, account, verification)

- [X] T009 Create Alembic migration `002_truncate_demo_tasks.py` to delete all existing demo tasks
  - **File**: `backend/alembic/versions/7a3b5c8d9e1f_truncate_demo_tasks.py`
  - **Content**: `TRUNCATE TABLE tasks;`
  - **Verification**: Check file exists with `ls backend/alembic/versions/7a3b5c8d9e1f_*.py`

- [X] T010 Create Alembic migration `003_update_tasks_user_id.py` to change tasks.user_id column type to UUID and add foreign key
  - **File**: `backend/alembic/versions/8b4c6d7e0f2a_update_tasks_user_id_for_auth.py`
  - **Content**: `ALTER TABLE tasks ALTER COLUMN user_id TYPE UUID; ADD CONSTRAINT fk_tasks_user_id FOREIGN KEY (user_id) REFERENCES neon_auth.user(id);`
  - **Verification**: Check file exists with `ls backend/alembic/versions/8b4c6d7e0f2a_*.py`

- [X] T011 Apply all Alembic migrations using `alembic upgrade head`
  - **Location**: `backend/`
  - **Command**: `cd backend && alembic upgrade head`
  - **Verification**: Use Neon MCP `get_database_tables` to confirm all tables exist (users, sessions, accounts, tasks) and run `describe_table_schema` on tasks table to verify user_id is UUID type with FK

**Checkpoint**: Foundation ready - user story implementation can now begin

---

## Phase 3: User Story 1 - New User Registration (Priority: P1) üéØ MVP

**Goal**: Enable new users to create accounts via signup page and automatically log in
**Independent Test**: Navigate to `/signup`, enter credentials, submit form, verify redirect to `/dashboard` with active session
**Agent**: frontend-dev-agent

### Implementation for User Story 1

- [X] T012 [MCP Context] Use Better Auth MCP to search for "email password authentication configuration" patterns
  - **Query**: "Better Auth setup for Next.js App Router with email/password authentication"
  - **Verification**: Review returned configuration examples

- [X] T013 [MCP Context] Use Shadcn MCP `search_items_in_registries` to search for "form" components
  - **Query**: "form input button card"
  - **Verification**: Confirm Form, Input, Button, Card components are available in registry

- [X] T014 [P] [US1] Configure Better Auth in `frontend/lib/auth.ts` with email/password provider
  - **File**: `frontend/lib/auth.ts` + `frontend/lib/auth-client.ts`
  - **Content**: Better Auth server instance with emailPassword + PostgreSQL pool, and client instance for React
  - **Verification**: Files created with correct configuration

- [X] T015 [P] [US1] Create auth utility hook in `frontend/hooks/useAuth.ts` wrapping Better Auth hooks
  - **File**: `frontend/hooks/useAuth.ts`
  - **Content**: Export `useSession`, `signUp`, `signIn`, `signOut` hooks from Better Auth React
  - **Verification**: File exists with `ls frontend/hooks/useAuth.ts` and exports all auth hooks

- [X] T016 [US1] Update `frontend/app/layout.tsx` to wrap children with Better Auth SessionProvider
  - **File**: `frontend/app/api/auth/[...all]/route.ts` (Note: Better Auth doesn't use SessionProvider)
  - **Content**: Created API route handler for Better Auth endpoints
  - **Verification**: API route created at correct location

- [X] T017 [P] [US1] Create SignupForm component in `frontend/components/auth/SignupForm.tsx` using Shadcn Form, Input, Button
  - **File**: `frontend/components/auth/SignupForm.tsx`
  - **Content**: Form with name, email, password fields using Shadcn Card, Input, Button; calls authClient.signUp.email; handles errors with toast; redirects to `/dashboard` on success
  - **Verification**: File exists with complete signup form implementation

- [X] T018 [US1] Create signup page at `frontend/app/signup/page.tsx` rendering SignupForm
  - **File**: `frontend/app/signup/page.tsx`
  - **Content**: Server component that renders SignupForm with heading "Create Account"
  - **Verification**: File exists with `ls frontend/app/signup/page.tsx` and imports SignupForm

- [ ] T019 [US1] Manual verification: Start frontend dev server, navigate to `/signup`, fill form, submit, verify user created in database
  - **Command**: `cd frontend && npm run dev` then open `http://localhost:3000/signup`
  - **Verification**: After form submission, use Neon MCP `run_sql` with `SELECT * FROM neon_auth.user WHERE email = '[test-email]';` to confirm user exists

**Checkpoint**: User Story 1 (Registration) is fully functional and independently testable

---

## Phase 4: User Story 2 - Existing User Login (Priority: P1)

**Goal**: Enable returning users to log in and access their existing tasks
**Independent Test**: Navigate to `/login`, enter valid credentials, verify redirect to `/dashboard` with access to user's tasks only
**Agent**: frontend-dev-agent

### Implementation for User Story 2

- [ ] T020 [P] [US2] Create LoginForm component in `frontend/components/auth/LoginForm.tsx` using Shadcn Form, Input, Button
  - **File**: `frontend/components/auth/LoginForm.tsx`
  - **Content**: Form with email, password fields; call `signIn` from useAuth; handle errors; redirect to `/dashboard` on success
  - **Verification**: File exists with `ls frontend/components/auth/LoginForm.tsx` and contains form fields and signIn call

- [ ] T021 [US2] Create login page at `frontend/app/login/page.tsx` rendering LoginForm
  - **File**: `frontend/app/login/page.tsx`
  - **Content**: Server component that renders LoginForm with heading "Welcome Back"
  - **Verification**: File exists with `ls frontend/app/login/page.tsx` and imports LoginForm

- [ ] T022 [US2] Manual verification: Start frontend, navigate to `/login`, enter valid credentials (from US1 signup), verify redirect to `/dashboard`
  - **Command**: Open `http://localhost:3000/login` in browser
  - **Verification**: After login, browser redirects to `/dashboard` and session is active (check via `useSession` hook)

**Checkpoint**: User Story 2 (Login) is fully functional and independently testable

---

## Phase 5: User Story 3 - Protected Dashboard Access (Priority: P1)

**Goal**: Protect `/dashboard` route so only authenticated users can access it
**Independent Test**: Attempt to access `/dashboard` without login (should redirect to `/login`), log in, verify access granted
**Agent**: frontend-dev-agent

### Implementation for User Story 3

- [ ] T023 [MCP Context] Use Next.js MCP `nextjs_docs` to search for "middleware authentication" patterns
  - **Query**: "Next.js 16 middleware route protection authentication"
  - **Verification**: Review returned middleware patterns for authentication checks

- [ ] T024 [P] [US3] Move existing task interface from `frontend/app/page.tsx` to `frontend/app/dashboard/page.tsx`
  - **Files**: Move `frontend/app/page.tsx` ‚Üí `frontend/app/dashboard/page.tsx`
  - **Content**: Copy entire existing page.tsx content (TaskList, CreateTaskForm) to dashboard/page.tsx
  - **Verification**: Run `ls frontend/app/dashboard/page.tsx` and confirm file exists with task management UI

- [ ] T025 [P] [US3] Create new public landing page at `frontend/app/page.tsx` with welcome message and auth CTAs
  - **File**: `frontend/app/page.tsx`
  - **Content**: Simple landing page with "Welcome to Task Manager" heading, description, "Sign Up" and "Login" buttons (Link to /signup and /login)
  - **Verification**: File exists with `ls frontend/app/page.tsx` and contains welcome message and auth buttons

- [ ] T026 [US3] Implement route protection middleware in `frontend/middleware.ts` to redirect unauthenticated users from `/dashboard` to `/login`
  - **File**: `frontend/middleware.ts`
  - **Content**: Check session using Better Auth; if no session and path is `/dashboard`, redirect to `/login`; allow `/`, `/login`, `/signup`
  - **Verification**: File exists with `ls frontend/middleware.ts` and contains authentication check logic

- [ ] T027 [US3] Manual verification: Access `/dashboard` in incognito (no session), verify redirect to `/login`; log in, verify `/dashboard` access granted
  - **Command**: Open `http://localhost:3000/dashboard` in incognito browser
  - **Verification**: Browser redirects to `/login`; after login, `/dashboard` is accessible

**Checkpoint**: User Story 3 (Route Protection) is fully functional and independently testable

---

## Phase 6: User Story 4 - User Data Isolation (Priority: P2)

**Goal**: Ensure each user only sees their own tasks via backend authentication and data filtering
**Independent Test**: Create two users, have each create tasks, verify User A sees only their tasks (not User B's)
**Agent**: backend-dev-agent

### Implementation for User Story 4

- [ ] T028 [MCP Context] Use Better Auth MCP to search for "JWT token structure claims" information
  - **Query**: "Better Auth JWT token payload structure user ID claim"
  - **Verification**: Review returned JWT structure documentation

- [ ] T029 [P] [US4] Create JWT verification module in `backend/app/core/auth.py` with `verify_jwt_token` function
  - **File**: `backend/app/core/auth.py`
  - **Content**: Function to decode JWT using `BETTER_AUTH_SECRET` from env; extract `user_id` claim; handle expiration and signature errors
  - **Verification**: File exists with `ls backend/app/core/auth.py` and contains `verify_jwt_token` function

- [ ] T030 [P] [US4] Update `backend/app/core/config.py` to load `BETTER_AUTH_SECRET` from environment
  - **File**: `backend/app/core/config.py`
  - **Modification**: Add `BETTER_AUTH_SECRET: str` to Settings class
  - **Verification**: Run `grep BETTER_AUTH_SECRET backend/app/core/config.py` and confirm env var is loaded

- [ ] T031 [US4] Create `get_current_user` dependency in `backend/app/api/dependencies.py` that verifies JWT and returns user_id
  - **File**: `backend/app/api/dependencies.py`
  - **Content**: Dependency function that extracts Authorization header, calls `verify_jwt_token`, returns user_id or raises HTTPException(401)
  - **Verification**: File exists with `ls backend/app/api/dependencies.py` and contains `get_current_user` function

- [ ] T032 [US4] Remove `DEMO_USER_ID` constant from `backend/app/utils/constants.py`
  - **File**: `backend/app/utils/constants.py`
  - **Modification**: Delete `DEMO_USER_ID = "demo-user-123"` line
  - **Verification**: Run `grep DEMO_USER_ID backend/app/utils/constants.py` and confirm constant is removed (should return no results)

- [ ] T033 [US4] Update `backend/app/api/routes/tasks.py` to inject `user_id: str = Depends(get_current_user)` into all endpoints
  - **File**: `backend/app/api/routes/tasks.py`
  - **Modifications**:
    - Import `get_current_user` from dependencies
    - Add `user_id: str = Depends(get_current_user)` parameter to `list_tasks`, `create_task`, `update_task`, `delete_task`
    - Replace all instances of `DEMO_USER_ID` with the injected `user_id` parameter
    - Update `create_task` to use `user_id` instead of hardcoded constant
    - Update `list_tasks` filter to `where(Task.user_id == user_id)`
    - Update `update_task` and `delete_task` ownership checks to compare `task.user_id == user_id`
  - **Verification**: Run `grep "Depends(get_current_user)" backend/app/api/routes/tasks.py` and confirm all 4 endpoints have the dependency; run `grep DEMO_USER_ID backend/app/api/routes/tasks.py` and confirm no references remain

- [ ] T034 [US4] Update `frontend/lib/api.ts` to include Authorization header with JWT token in all API requests
  - **File**: `frontend/lib/api.ts`
  - **Modification**: Add `Authorization: Bearer ${token}` header to fetch calls; get token from Better Auth session
  - **Verification**: Run `grep Authorization frontend/lib/api.ts` and confirm header is added to requests

- [ ] T035 [US4] Backend security verification: Use curl to call `/api/tasks` without Authorization header and confirm 401 Unauthorized
  - **Command**: `curl -X GET http://localhost:8000/api/tasks -v`
  - **Verification**: Response status code is 401 and response body contains `{"detail": "Unauthorized"}` or similar auth error message

- [ ] T036 [US4] Manual multi-user verification: Create User A and User B accounts, have each create distinct tasks, log in as each user, verify data isolation
  - **Steps**:
    1. Sign up User A, create Task "A1" and "A2"
    2. Sign up User B, create Task "B1" and "B2"
    3. Log in as User A, verify only "A1" and "A2" are visible in dashboard
    4. Log in as User B, verify only "B1" and "B2" are visible in dashboard
  - **Verification**: Each user sees only their own tasks; no cross-user data leakage

**Checkpoint**: User Story 4 (Data Isolation) is fully functional and independently testable

---

## Phase 7: User Story 5 - Public Landing Page (Priority: P3)

**Goal**: Provide welcoming landing page for visitors (already completed in Phase 5, Task T025)
**Independent Test**: Visit `/` while logged out, verify welcome message and auth buttons present
**Agent**: frontend-dev-agent

### Implementation for User Story 5

- [ ] T037 [US5] Enhance landing page at `frontend/app/page.tsx` with welcome messaging and feature highlights
  - **File**: `frontend/app/page.tsx`
  - **Modification**: Add hero section with app description, feature bullet points, and prominent CTAs
  - **Verification**: Visit `http://localhost:3000/` and confirm enhanced landing page with welcome content

- [ ] T038 [US5] (Optional) Add redirect logic to landing page: if user is already logged in, redirect to `/dashboard`
  - **File**: `frontend/app/page.tsx`
  - **Modification**: Check session using `useSession` hook; if session exists, redirect to `/dashboard` using Next.js navigation
  - **Verification**: Log in, then visit `/`, verify automatic redirect to `/dashboard`

**Checkpoint**: User Story 5 (Landing Page) is fully functional and independently testable

---

## Phase 8: Integration & QA Verification

**Purpose**: End-to-end verification of all user stories working together
**Agent**: qa-spec-validator

- [ ] T039 Full integration smoke test: Execute complete user journey from landing ‚Üí signup ‚Üí dashboard ‚Üí task creation ‚Üí logout ‚Üí login
  - **Steps**:
    1. Visit `/` (Landing) - verify welcome message
    2. Click "Sign Up" - verify redirect to `/signup`
    3. Fill signup form and submit - verify redirect to `/dashboard`
    4. Create a new task - verify task appears in list
    5. Sign out (implement logout button if needed)
    6. Visit `/dashboard` directly - verify redirect to `/login`
    7. Log in with same credentials - verify redirect to `/dashboard` with previously created task visible
  - **Verification**: All steps complete successfully without errors; session persists across browser refreshes

- [ ] T040 Cross-browser verification: Test authentication flow in Chrome, Firefox, and Safari
  - **Verification**: All user stories work identically across all three browsers

- [ ] T041 Security verification: Attempt common auth bypass attacks (missing token, tampered token, expired token)
  - **Tests**:
    - Call `/api/tasks` with no Authorization header ‚Üí 401
    - Call `/api/tasks` with invalid JWT ‚Üí 401
    - Call `/api/tasks` with User A's token but User B's task ID ‚Üí 403 or 404
  - **Verification**: All unauthorized access attempts are properly rejected

---

## Dependencies & Execution Order

### Phase Dependencies

- **Setup (Phase 1)**: No dependencies - can start immediately
- **Foundational (Phase 2)**: Depends on Setup (Phase 1) - BLOCKS all user stories
- **User Stories (Phase 3-7)**: All depend on Foundational (Phase 2) completion
  - User Stories 1-3 (P1): Core authentication flow - sequential dependencies
  - User Story 4 (P2): Depends on US1-3 being functional
  - User Story 5 (P3): Independent, can be done anytime after Phase 1
- **Integration (Phase 8)**: Depends on all user stories being complete

### User Story Dependencies

- **User Story 1 (Registration)**: Depends on Phase 2 (database schema)
- **User Story 2 (Login)**: Depends on US1 (users must exist to log in)
- **User Story 3 (Route Protection)**: Depends on US1 and US2 (authentication flow must work)
- **User Story 4 (Data Isolation)**: Depends on US1-3 (full auth flow must work before backend security)
- **User Story 5 (Landing Page)**: Independent - only depends on Phase 1

### Within Each User Story

- MCP Context checks before implementation
- Frontend components before pages
- Middleware after pages exist
- Backend auth logic after frontend is ready to send tokens
- Verification after implementation

### Parallel Opportunities

- **Phase 1**: T004 (frontend deps) and T005 (backend deps) can run in parallel
- **Phase 2**: T008, T009, T010 (migration files) can be created in parallel
- **Phase 3 (US1)**: T013, T014, T015 can run in parallel (different files)
- **Phase 4 (US2)**: T020, T021 can run in parallel (different files)
- **Phase 5 (US3)**: T024, T025 can run in parallel (different files)
- **Phase 6 (US4)**: T029, T030 can run in parallel (different files)

---

## Parallel Example: User Story 4

```bash
# Launch backend auth infrastructure in parallel:
Task T029: "Create JWT verification in backend/app/core/auth.py"
Task T030: "Update config in backend/app/core/config.py"

# Sequential after parallel tasks complete:
Task T031: "Create get_current_user dependency" (depends on T029)
Task T033: "Update task routes with dependency" (depends on T031)
```

---

## Implementation Strategy

### MVP First (User Stories 1-3 Only)

1. Complete Phase 1: Setup & Configuration
2. Complete Phase 2: Database Schema (CRITICAL - blocks all stories)
3. Complete Phase 3: User Registration (US1)
4. Complete Phase 4: User Login (US2)
5. Complete Phase 5: Route Protection (US3)
6. **STOP and VALIDATE**: Test complete authentication flow end-to-end
7. Deploy/demo if ready (functional MVP without backend security)

### Full Security Implementation

After MVP validation:
1. Complete Phase 6: User Data Isolation (US4) - adds backend JWT verification
2. **STOP and VALIDATE**: Test multi-user data isolation
3. Deploy/demo secure multi-user app

### Polish & Launch

After security implementation:
1. Complete Phase 7: Landing Page (US5) - enhances UX
2. Complete Phase 8: Integration & QA
3. Final production deployment

### Parallel Team Strategy

With multiple developers:

1. **Team completes Phase 1-2 together** (Setup + Database)
2. Once Phase 2 done, split:
   - **Developer A**: Phase 3 (US1 Registration)
   - **Developer B**: Phase 4 (US2 Login) after US1 completes
   - **Developer C**: Phase 7 (US5 Landing Page) - independent
3. After US1-3 complete:
   - **Developer A**: Phase 6 (US4 Backend Security)
   - **Developer B**: Phase 8 (QA Testing)
4. Stories integrate and test together

---

## Notes

- **[P] tasks** = different files, no dependencies - can run in parallel
- **[Story] label** maps task to specific user story for traceability
- **MCP Context** tasks ensure we use available MCP servers before implementation
- Each user story should be independently completable and testable
- Commit after each task or logical group
- Stop at any checkpoint to validate story independently
- All environment secrets (`BETTER_AUTH_SECRET`) must match exactly between frontend and backend
- Database migrations (Phase 2) are critical blocker - must complete before any user story work
- Manual verification steps include specific commands and expected outcomes
